name: Build and Review PR
run-name: 'Build and Review PR #${{ github.event.pull_request.number }}'

on:
  # https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
  #
  # This workflow uses the pull_request trigger which prevents write permissions on the
  # GH_TOKEN and secrets access from public forks.  This should remain as a pull_request
  # trigger to minimize the access public forks have in the repository.  The reduced
  # permissions are adequate but do mean that re-compiles and readme changes will have to be
  # made manually by the PR author.  These auto-updates could be done by this workflow
  # for branches but in order to re-trigger a PR build (which is needed for status checks),
  # we would make the commits with a different user and their PAT.  To minimize exposure
  # and complication we will request those changes be manually made by the PR author.

  pull_request:
    types: [opened, synchronize, reopened]
  # paths:
  #   Do not include specific paths here.  We always want this build to run and produce a
  #   status check which are branch protection rules can use.  If this is skipped because of
  #   path filtering, a status check will not be created and we won't be able to merge the PR
  #   without disabling that requirement.  If we have a status check that is always produced,
  #   we can also use that to require all branches be up to date before they are merged.

jobs:
  build-and-review-pr:
    # This reusable workflow will check to see if an action's source code has changed based on
    # whether the PR includes files that match the files-with-code arg or are in one of the
    # dirs-with-code directories.  If there are source code changes, this reusable workflow
    # will then run the action's build (if one was provided) and update the README.md with the
    # the latest version of the action.  If those two steps result in any changes that need to
    # be committed, the workflow will fail because the PR needs some updates.  Instructions for
    # updating the PR will be available in the build log, the workflow summary and as a PR
    # comment if the PR came from a branch (not a fork).
    # This workflow assumes:
    #  - The main README.md is at the root of the repo
    #  - The README contains a contribution guidelines and usage examples section
    uses: im-open/.github/.github/workflows/reusable-build-and-review-pr.yml@v1
    with:
      action-name: ${{ github.repository }}
      default-branch: main
      readme-name: 'README.md'

      # The id of the contribution guidelines section of the README.md
      readme-contribution-id: '#contributing'

      # The id of the usage examples section of the README.md
      readme-examples-id: '#usage-examples'

      # The files that contain source code for the action.  Only files that affect the action's execution
      # should be included like action.yml or package.json.  Do not include files like README.md or .gitignore.
      # Files do not need to be explicitly provided here if they fall under one of the dirs in dirs-with-code.
      # ** This value must match the same files-with-code argument specified in increment-version-on-merge.yml.
      files-with-code: 'action.yml'

      # The directories that contain source code for the action.  Only dirs with files that affect the action's
      # execution should be included like src or dist.  Do not include dirs like .github or node_modules.
      # ** This value must match the same dirs-with-code argument specified in increment-version-on-merge.yml.
      dirs-with-code: ''

      # The npm script to run to build the action.  This is typically 'npm run build' if the
      # action needs to be compiled.  For composite-run-steps actions this is typically empty.
      build-command: ''

  test:
    runs-on: ubuntu-latest

    env:
      # COMMITISH: '574597c0dfddc1fd1abcb99f368b156c78dadbe0' # v1.2.1
      COMMITISH: 'b1abda215613c5ffad9e2975cada5edb7eeb2c56' # v1.3.0
      REPO: 'im-open/download-release-asset'

      ERROR_RELEASE_DOES_NOT_EXIST: 'Release with tag does not exist'
      ERROR_ASSET_DOES_NOT_EXIST: 'No assets match the name'
      ERROR_NO_ASSETS_ON_RELEASE: 'Release does not have assets'
      ERROR_UNKNOWN: 'Unknown error getting release'

      NO_ASSETS_TAG: ''
      RELEASE_TAG: ''

      ASSET_1_NAME: ''
      ASSET_2_NAME: ''

    steps:
      #--------------------------------------
      # SETUP
      #--------------------------------------
      - name: Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires write scopes on GITHUB_TOKEN that PRs from forks will not have access to.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: Setup - Dynamically generate a tag for the release & asset name
        run: |
          tag=$(date +'%Y%m%d%H%M%S')
          echo "NO_ASSETS_TAG=noAssetsTest_$tag" >> $GITHUB_ENV
          echo "RELEASE_TAG=downloadTest_$tag" >> $GITHUB_ENV
          echo "ASSET_1_NAME=my_test_asset_1_$tag.txt" >> $GITHUB_ENV
          echo "ASSET_2_NAME=my_test_asset_2_$tag.txt" >> $GITHUB_ENV

      - name: Setup - Create a release with no assets
        uses: im-open/create-release@v3
        id: no-assets
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          tag-name: ${{ env.NO_ASSETS_TAG }}
          commitish: ${{ env.COMMITISH }}

      - name: Setup - Create a release with an asset
        uses: im-open/create-release@v3
        id: release
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          tag-name: ${{ env.RELEASE_TAG }}
          commitish: ${{ env.COMMITISH }}
          asset-path: './test/files/test-asset-1.txt'
          asset-name: ${{ env.ASSET_1_NAME }}
          asset-content-type: 'application/text'

      - name: Setup - Upload a second asset
        uses: im-open/upload-release-asset@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          upload-url: ${{ steps.release.outputs.asset-upload-url }}
          asset-path: './test/files/test-asset-2.txt'
          asset-name: ${{ env.ASSET_2_NAME }}
          asset-content-type: 'application/text'

      #--------------------------------------
      # DOWNLOAD WITH A REPO NAME
      #--------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When downloading an asset and providing a repo name
        uses: ./
        if: always()
        id: download-with-name
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          asset-name: ${{ env.ASSET_1_NAME }}
          tag-name: ${{ env.RELEASE_TAG }}
          repository: ${{ env.REPO }}

      - name: Then the outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.download-with-name.outcome }}"

      - name: And the asset should exist in the current working directory and the contents should match the uploaded asset
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertAssetWasDownloaded = require('./test/assert-asset-was-downloaded.js')
            const downloadFilePath = '${{ steps.download-with-name.outputs.download-file-path }}';
            const expectedFilePath = './test/files/test-asset-1.txt';
            assertAssetWasDownloaded(core, fs, downloadFilePath, expectedFilePath);

      #--------------------------------------
      # DOWNLOAD WITHOUT A REPO NAME
      #--------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When downloading an asset without providing a repo name
        uses: ./
        if: always()
        id: download-no-name
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          asset-name: ${{ env.ASSET_2_NAME }}
          tag-name: ${{ env.RELEASE_TAG }}
          repository: ''

      - name: Then the outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.download-no-name.outcome }}"

      - name: And the asset should exist in the current working directory and the contents should match the uploaded asset
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertAssetWasDownloaded = require('./test/assert-asset-was-downloaded.js')
            const downloadFilePath = '${{ steps.download-no-name.outputs.download-file-path }}';
            const expectedFilePath = './test/files/test-asset-2.txt';
            assertAssetWasDownloaded(core, fs, downloadFilePath, expectedFilePath);

      #-------------------------------------------------------------------
      # CAUSE AN UNKNOWN ERROR
      #-------------------------------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When an unknown error occurs downloading the asset
        uses: ./
        if: always()
        id: unknown-error
        continue-on-error: true # This is needed because we expect the step to fail.  We need it to "pass" in order for the test job to succeed.
        with:
          github-token: 'abc-123' # This should fail since the built in token won't have access to another repo
          asset-name: ${{ env.ASSET_1_NAME }}
          tag-name: 'v3.0.0'

      - name: Then the outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.unknown-error.outcome }}"

      - name: And the error-condition output should indicate an unknown error has occurred
        if: always()
        run: |
          ./test/assert-values-match.sh --name "error-condition" --expected "${{ env.ERROR_UNKNOWN }}" --actual "${{ steps.unknown-error.outputs.error-condition }}"
          ./test/assert-values-match.sh --name "download-file-path" --expected "" --actual "${{ steps.unknown-error.outputs.download-file-path }}"
          ./test/assert-values-match.sh --name "download_file_path" --expected "" --actual "${{ steps.unknown-error.outputs.download_file_path }}"

      #-------------------------------------------------------------------
      # DOWNLOAD FROM AN EXISTING RELEASE THAT HAS NO ASSETS
      #-------------------------------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When downloading an asset from an existing release that has no assets
        uses: ./
        if: always()
        id: download-no-assets
        continue-on-error: true # This is needed because we expect the step to fail.  We need it to "pass" in order for the test job to succeed.
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          asset-name: ${{ env.ASSET_1_NAME }} # This won't exist on this release which has no assets
          tag-name: '${{ env.NO_ASSETS_TAG }}'
          repository: ${{ env.REPO }}

      - name: Then the outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.download-no-assets.outcome }}"

      - name: And the error-condition output should indicate the release has no assets
        if: always()
        run: |
          ./test/assert-values-match.sh --name "error-condition" --expected "${{ env.ERROR_NO_ASSETS_ON_RELEASE }}" --actual "${{ steps.download-no-assets.outputs.error-condition }}"
          ./test/assert-values-match.sh --name "download-file-path" --expected "" --actual "${{ steps.download-no-assets.outputs.download-file-path }}"
          ./test/assert-values-match.sh --name "download_file_path" --expected "" --actual "${{ steps.download-no-assets.outputs.download_file_path }}"

      #-------------------------------------------------------------------
      # DOWNLOAD FROM AN EXISTING RELEASE BUT AN ASSET THAT DOES NOT EXIST
      #-------------------------------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When downloading an asset that does not exist
        uses: ./
        if: always()
        id: non-existent-asset
        continue-on-error: true # This is needed because we expect the step to fail.  We need it to "pass" in order for the test job to succeed.
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          asset-name: 'abc-123-asset.prw' # This does not exist
          tag-name: '${{ env.RELEASE_TAG }}'
          repository: ${{ env.REPO }}

      - name: Then the outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.non-existent-asset.outcome }}"

      - name: And the error-condition output should indicate the asset does not exist
        if: always()
        run: |
          ./test/assert-values-match.sh --name "error-condition" --expected "${{ env.ERROR_ASSET_DOES_NOT_EXIST }}" --actual "${{ steps.non-existent-asset.outputs.error-condition }}"
          ./test/assert-values-match.sh --name "download-file-path" --expected "" --actual "${{ steps.non-existent-asset.outputs.download-file-path }}"
          ./test/assert-values-match.sh --name "download_file_path" --expected "" --actual "${{ steps.non-existent-asset.outputs.download_file_path }}"

      #--------------------------------------------
      # DOWNLOAD FROM A RELEASE THAT DOES NOT EXIST
      #--------------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When downloading an asset from a release that does not exist
        uses: ./
        if: always()
        id: non-existent-release
        continue-on-error: true # This is needed because we expect the step to fail.  We need it to "pass" in order for the test job to succeed.
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          asset-name: ${{ env.ASSET_1_NAME }}
          tag-name: 'v00.00.123' # This does not exist
          repository: ${{ env.REPO }}

      - name: Then the outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.non-existent-release.outcome }}"

      - name: And the error-condition output should indicate the release does not exist
        if: always()
        run: |
          ./test/assert-values-match.sh --name "error-condition" --expected "${{ env.ERROR_RELEASE_DOES_NOT_EXIST }}" --actual "${{ steps.non-existent-release.outputs.error-condition }}"
          ./test/assert-values-match.sh --name "download-file-path" --expected "" --actual "${{ steps.non-existent-release.outputs.download-file-path }}"
          ./test/assert-values-match.sh --name "download_file_path" --expected "" --actual "${{ steps.non-existent-release.outputs.download_file_path }}"

      # --------------------------------------
      # TEARDOWN
      # --------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: Teardown - Cleanup all the releases by deleting them
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            // Not all of these will end up with a tag and a release, but run them all just in case any of the tests
            // fail unexpectedly.  We don't want a bunch of test releases and tags cluttering up the real thing.

            const deleteReleaseFromGitHub = require('./test/teardown/delete-release-from-github.js')
            await deleteReleaseFromGitHub(github, core, '${{ steps.release.outputs.release-id }}');
            await deleteReleaseFromGitHub(github, core, '${{ steps.no-assets.outputs.release-id }}');

            const deleteTagFromGitHub = require('./test/teardown/delete-tag-from-github.js')
            await deleteTagFromGitHub(github, core, '${{ env.RELEASE_TAG }}');
            await deleteTagFromGitHub(github, core, '${{ env.NO_ASSETS_TAG }}');

      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""
